package controller

import (
	"context"
	"fmt"
	repvol "github.com/csi-addons/kubernetes-csi-addons/api/replication.storage/v1alpha1"
	repgrpc "github.com/csi-addons/spec/lib/go/replication"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

func sub(repclass repvol.VolumeReplicationClass) {
	fmt.Printf("%v\n", repclass)

}

type repAddonsServer struct {
}

//message EnableVolumeReplicationRequest {
// The identifier for this volume, generated by the plugin during
// CreateVolume CSI RPC call.
// This field is OPTIONAL.
// This field MUST contain enough information to uniquely identify
// this specific volume vs all other volumes supported by this plugin.
// This field SHALL be used by the CO in subsequent calls to refer to
// this volume.
// This field is deprecated. Please use "replication_source" to
// specify the replication source.
//  string volume_id = 1 [deprecated = true];
// The identifier for the replication.
// Plugin specific parameters passed in as opaque key-value pairs.
//  map<string, string> parameters = 2;
// Secrets required by the plugin to complete the request.
//  map<string, string> secrets = 3 [(csi.v1.csi_secret) = true];
// This field is OPTIONAL.
// This field MUST contain enough information, together with volume_id,
// to uniquely identify this specific replication
// vs all other replications supported by this plugin.
//  string replication_id = 4 [(alpha_field) = true];
// If specified, this field will contain volume or volume group id
// for replication.
//  ReplicationSource replication_source = 5;
//}

// Specifies what source the replication will be created from. One of the
// type fields MUST be specified.
//message ReplicationSource {
// VolumeSource contains the details about the volume to be replication
//  message VolumeSource {
// Contains identity information for the existing volume.
// This field is REQUIRED.
//    string volume_id = 1;
//  }
// VolumeGroupSource contains the details about
// the volume group to be replication
//  message VolumeGroupSource {
// Contains identity information for the existing volume group.
// This field is REQUIRED.
//    string volume_group_id = 1;
//  }

//  oneof type {
// Volume source type
//    VolumeSource volume = 1;
// Volume group source type
//    VolumeGroupSource volumegroup = 2;
//  }
//}

// For POWERSTORE:
// EnableVolumeReplication enables replication on an existing volume. This is different than the way Dell replication works which requires specifying replication
// at the time of volume creation.
// The basic steps seem to be:
// 1. Validate the requested volume is not already replicated. That can be by validating annotations on the or from the VolumeHandle config map.
// 2. Determine the remote array to be used for replication.
// 3. It appears that Powerstore replication requires a ReplicationGroup.
// 4. Referring to CreateVolume the case "if replicationEnabled == "true" ", it appears that the follow steps are taken to create the replicated volume
// 4a. The replication mode, and RPO are taken in our case from the parameters of the EnableVolumeReplicationRequest
// 4b. The volume group is ALWAYS assumed. See the code in CreateVolume GetVolumeGroupBy Name.
// 4c. If the volume group does not exist, it is created.
// 5. I don't see any calls within the driver to CreateRemoteVolume. I'm guessing this is done always by the replication sidecar?
// 5a. It appears this happens in persistentvolume_controller.go in function Reconcile and the client interface to the remote csi extensions is in replication.go
// function CreateRemoteVolume.

func (*repAddonsServer) EnableVolumeReplication(context.Context, *repgrpc.EnableVolumeReplicationRequest) (*repgrpc.EnableVolumeReplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method EnableVolumeReplication not implemented")
}
func (*repAddonsServer) DisableVolumeReplication(context.Context, *repgrpc.DisableVolumeReplicationRequest) (*repgrpc.DisableVolumeReplicationResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DisableVolumeReplication not implemented")
}
func (*repAddonsServer) PromoteVolume(context.Context, *repgrpc.PromoteVolumeRequest) (*repgrpc.PromoteVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method PromoteVolume not implemented")
}
func (*repAddonsServer) DemoteVolume(context.Context, *repgrpc.DemoteVolumeRequest) (*repgrpc.DemoteVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DemoteVolume not implemented")
}
func (*repAddonsServer) ResyncVolume(context.Context, *repgrpc.ResyncVolumeRequest) (*repgrpc.ResyncVolumeResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ResyncVolume not implemented")
}
func (*repAddonsServer) GetVolumeReplicationInfo(context.Context, *repgrpc.GetVolumeReplicationInfoRequest) (*repgrpc.GetVolumeReplicationInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetVolumeReplicationInfo not implemented")
}
